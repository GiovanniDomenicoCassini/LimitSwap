def antirug(token, inToken, outToken):
    printt_debug("ENTER antirug")
    
    printt(" ", write_to_log=False)
    printt("-----------------------------------------------------------------------------------------------------------------------------", write_to_log=True)
    printt("ANTIRUG is enabled", write_to_log=True)
    printt("", write_to_log=True)

    if token['ANTIRUG'] == 'true' 
        printt(Bot will scan mempool to detect RUGS", write_to_log=True)
        printt(" ", write_to_log=False)
        printt("there is a LOT of ways to detect rugs, so we cannot be 100% to detect it in the mempool", write_to_log=False)
        printt(" ", write_to_log=False)
        printt_err("---- BE CAREFUL ----", write_to_log=True)
        printt(" ", write_to_log=False)
        printt("------------------------------------------------------------------------------------------------------------------------------", write_to_log=True)

    if token['ANTIRUG'] == 'mempool':
        printt("It will scan mempool to detect rugs", write_to_log=True)
        printt("------------------------------------------------------------------------------------------------------------------------------", write_to_log=True)

    openTrade = False

    token['_PREVIOUS_QUOTE'] = check_price(inToken, outToken, token['USECUSTOMBASEPAIR'], token['LIQUIDITYINNATIVETOKEN'], int(token['_CONTRACT_DECIMALS']), int(token['_BASE_DECIMALS']))
    
    # It looks ruggy, we look into Address's transactions for 0xbaa2abde methodID
    if token['ANTIRUG'] == 'mempool'
        tx_filter = client.eth.filter({"filter_params": "pending", "address": Web3.toChecksumAddress(token['ADDRESS'])})
    else:
        tx_filter = client.eth.filter({"filter_params": "pending", "address": inToken})
 
    if token['ANTIRUG'] == 'mempool':
        # Function: removeliquidity() - check examples below
        list_of_methodId = ["0xbaa2abde"]
    else:
        list_of_methodId = ["0x02751cec", "0xaf2979eb", "0xded9382a", "0x5b0d5984", "0x2195995c"]

    while openTrade == False
    
    if token['ANTIRUG'] == 'mempool':
            pprice = check_price(inToken, outToken, token['USECUSTOMBASEPAIR'], token['LIQUIDITYINNATIVETOKEN'], int(token['_CONTRACT_DECIMALS']), int(token['_BASE_DECIMALS']))
    
            if pprice != float(token['_PREVIOUS_QUOTE']):
                token['_SELL_BEFORE_RUG'] = True
                printt_ok("Token price:", pprice, "--> SOMETHING IS HAPPENING :)", write_to_log=True)
                printt_ok("RUG IS HAPPENING --> rug is imminent --> Bot will sell", write_to_log=True)
                break

            printt("Token price:", pprice)        


        try:
            for tx_event in tx_filter.get_new_entries():

                txHash = tx_event['transactionHash']
                txHashDetails = client.eth.get_transaction(txHash)
                # printt_debug(txHashDetails)
                txFunction = txHashDetails.input[:10]
                if txFunction.lower() in list_of_methodId:
                    antiRug = True
                    token['_GAS_IS_CALCULATED'] = True
                    token['_GAS_TO_USE'] = int(txHashDetails.gasPrice) / 1000000000
                    printt_ok("Rug pull detected --> Rug is happening --> Bot will sell asap", write_to_log=True)
                    printt_ok("MethodID: ", txFunction, " Block: ", tx_event['blockNumber'], " Found Signal", "in txHash:", txHash.hex(), write_to_log=True)
                    printt_ok("GAS will be the same as liquidity adding event. GAS=", token['_GAS_TO_USE'])
                    break
                else:
                    printt("Found something in mempool - MethodID: ", txFunction, " Block: ", tx_event['blockNumber'])
        except Exception as e:
            printt_err("ANTIRUG Error. It can happen with Public node : private node is recommended. Still, let's continue.")
            continue
